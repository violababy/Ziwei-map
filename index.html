<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>ç´«å¾®é£›æ˜Ÿè¦–è¦ºå¼•æ“</title>

  <style>
    body{
      font-family: "Segoe UI", Arial, sans-serif;
      background:#f4f6f8;
      margin:0;
      padding:18px;
      color:#111;
    }
    h1{
      text-align:center;
      margin:8px 0 14px;
      font-size:28px;
      letter-spacing:1px;
    }
    .wrap{
      max-width:1200px;
      margin:0 auto;
    }
    .panel{
      background:#fff;
      border-radius:14px;
      box-shadow:0 4px 14px rgba(0,0,0,.10);
      padding:14px;
      overflow-x:auto;
    }

    svg{
      background:#fff;
    }

    .palace-rect{
      fill:#fbfcfd;
      stroke:#2a2a2a;
      stroke-width:1.8;
      rx:14;
    }
    .palace-name{
      font-size:18px;
      font-weight:700;
      text-anchor:middle;
      fill:#111;
    }
    .palace-stem{
      font-size:16px;
      font-weight:700;
      text-anchor:end;
      fill:#118a2a; /* å®®å¹²ç¶ å­—ï¼ˆå¯æ”¹ï¼‰ */
    }
    .body-star{
      font-size:22px;
      font-weight:900;
      fill:#d72b2b;
    }

/* ===== æ˜Ÿæ›œè¦–è¦ºåˆ†å±¤ ===== */

/* ä¸»æ˜Ÿï¼šç´…è‰²ã€æœ€å¤§ã€æœ€é†’ç›® */
.star-main{
  fill:#d72b2b;
  font-weight:900;
  font-size:17px;
}

/* å‰æ˜Ÿ / ç…æ˜Ÿï¼šé»‘è‰²ã€ç²—é«” */
.star-good,
.star-bad{
  fill:#111;
  font-weight:800;
  font-size:15px;
}

/* ä¹™ç´šæ˜Ÿï¼šå°å­—ã€æ·ºç°ã€é™æ¬Š */
.star-sub{
  fill:#9aa0a6;
  font-weight:500;
  font-size:12px;
}

    .star-text{
      font-size:15px;
      text-anchor:middle;
      dominant-baseline:middle;
    }

    .mark{
      font-size:12px;
      font-weight:900;
      text-anchor:middle;
      dominant-baseline:middle;
    }
    .mark-lu { fill:#0b6b2d; }     /* ç¥¿ æ·±ç¶  */
    .mark-quan{ fill:#0b2f8a; }    /* æ¬Š æ·±è— */
    .mark-ke { fill:#2b86ff; }     /* ç§‘ æ·ºè— */
    .mark-ji { fill:#d72b2b; }     /* å¿Œ ç´… */

    .arrow{
      fill:none;
      stroke-width:1.6;   /* ç·šç´°ä¸€é» */
      opacity:.95;
    }
    .arrow-lu { stroke:#0b6b2d; }
    .arrow-quan{ stroke:#0b2f8a; }
    .arrow-ke { stroke:#2b86ff; }
    .arrow-ji { stroke:#d72b2b; }

    .hint{
      font-size:13px;
      color:#555;
      margin:10px 0 0;
      line-height:1.5;
    }
    .err{
      color:#b00020;
      font-weight:700;
      white-space:pre-wrap;
      margin-top:10px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>ğŸ”® ç´«å¾®é£›æ˜Ÿè¦–è¦ºå¼•æ“ï¼ˆè³‡æ–™é©…å‹•ç‰ˆï¼‰</h1>

    <div class="panel">
<svg id="svg" width="1100" height="800" viewBox="0 0 1100 800" aria-label="ziwei-map">
<defs>
  <marker id="m-lu" markerWidth="16" markerHeight="16" refX="14" refY="8" orient="auto">
    <path d="M0,0 L10,5 L0,10 Z" fill="#0b6b2d"></path>
  </marker>

  <marker id="m-quan" markerWidth="16" markerHeight="16" refX="14" refY="8" orient="auto">
    <path d="M0,0 L10,5 L0,10 Z" fill="#0b2f8a"></path>
  </marker>

  <marker id="m-ke" markerWidth="16" markerHeight="16" refX="14" refY="8" orient="auto">
    <path d="M0,0 L10,5 L0,10 Z" fill="#2b86ff"></path>
  </marker>

  <marker id="m-ji" markerWidth="16" markerHeight="16" refX="14" refY="8" orient="auto">
    <path d="M0,0 L10,5 L0,10 Z" fill="#d72b2b"></path>
  </marker>
</defs>

  <g id="arrow-layer"></g>
  <g id="box-layer"></g>
</svg>

      <div class="hint">
        âœ… è³‡æ–™ä¾†æºï¼šGoogle Sheetï¼ˆCSVï¼‰<br/>
        âœ… æ˜Ÿæ›œé¡è‰²ï¼šä¸»æ˜Ÿé»‘ç²—é«” / å‰æ˜Ÿæ·±ç¶ ç²—é«” / ç…æ˜Ÿç´…ç²—é«” / ä¹™ç´šæ˜Ÿé»‘å­—<br/>
        âœ… ç”Ÿå¹´å››åŒ–ï¼šé¡¯ç¤ºåœ¨æ˜Ÿåã€Œä¸‹æ–¹ã€ï¼›è‡ªåŒ–ï¼šé¡¯ç¤ºåœ¨æ˜Ÿåã€Œä¸Šæ–¹ã€<br/>
        âœ… é£›åŒ–ç·šï¼šç”±ã€Œèµ·å®®ã€å°„å‘ã€Œè©²åŒ–æ˜Ÿæ‰€åœ¨å®®ã€ï¼Œç®­é ­æ–¹å‘æ¸…æ¥šï¼›åŒèµ·é»ç·šæœƒå¾®åç§»æ¸›å°‘é‡ç–Š
      </div>

      <div id="err" class="err" style="display:none;"></div>
    </div>
  </div>

<script>
/** ========= ä½ æä¾›çš„ CSV ========= */
const NATAL_CSV_URL =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vTkNreRfwK7wRhPyQF-hSpVYN_tOlne58Ozjofq6vNxiKZSC7Xd2jfyaK6qE0RsjXYI_WWEKDlZaPIk/pub?gid=0&single=true&output=csv";

const TRANSFORM_CSV_URL =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vTkNreRfwK7wRhPyQF-hSpVYN_tOlne58Ozjofq6vNxiKZSC7Xd2jfyaK6qE0RsjXYI_WWEKDlZaPIk/pub?gid=1520997816&single=true&output=csv";


/** ========= å®®ä½åº§æ¨™ï¼ˆä½ ç›®å‰çš„å›ºå®šæ–¹å½¢æ’åˆ—ï¼‰ =========
 *  ä½ å…ˆç”¨é€™å€‹æ’åˆ—ï¼ˆç©©å®šæ„Ÿï¼‰ï¼Œä¹‹å¾Œè¦æ”¯æ´ä¸åŒæ´¾åˆ¥/ä¸åŒæ’ç›¤ï¼Œå†æŠŠåº§æ¨™è¡¨æ›æˆè³‡æ–™é©…å‹•å³å¯
 */
const layout = {
  // ç›’å­å°ºå¯¸
  w: 180, h: 110,
  // 12 å®®åº§æ¨™ï¼ˆå·¦ä¸Šè§’ï¼‰
  // ä¸Šæ’ï¼šP10 P11 P12 P1
  P10:{ x:100, y:60 },  P11:{ x:320, y:60 },  P12:{ x:540, y:60 },  P1:{ x:760, y:60 },
  // å·¦å´ä¸­æ’ï¼šP9 P8
  P9:{ x:100, y:230 },  P8:{ x:100, y:400 },
  // å³å´ä¸­æ’ï¼šP2 P3
  P2:{ x:760, y:230 },  P3:{ x:760, y:400 },
  // ä¸‹æ’ï¼šP7 P6 P5 P4
  P7:{ x:100, y:570 },  P6:{ x:320, y:570 },  P5:{ x:540, y:570 },  P4:{ x:760, y:570 },
};

/** ========= å°å·¥å…· ========= */
function showError(msg){
  const el = document.getElementById("err");
  el.style.display = "block";
  el.textContent = msg;
}

function trimCell(s){
  return (s ?? "").toString().trim();
}

/** ç°¡æ˜“ CSV parserï¼ˆæ”¯æ´å¼•è™Ÿï¼‰ */
function parseCSV(text){
  const rows = [];
  let row = [];
  let cur = "";
  let inQ = false;

  for(let i=0;i<text.length;i++){
    const c = text[i];
    const n = text[i+1];

    if(c === '"' ){
      if(inQ && n === '"'){ cur += '"'; i++; }
      else inQ = !inQ;
      continue;
    }
    if(!inQ && (c === "," || c === "\n" || c === "\r")){
      if(c === "\r" && n === "\n") { /* windows newline */ }
      row.push(cur);
      cur = "";
      if(c !== ","){
        // end row
        // skip blank row
        if(row.some(v => trimCell(v)!=="")) rows.push(row);
        row = [];
      }
      continue;
    }
    cur += c;
  }
  // last cell
  row.push(cur);
  if(row.some(v => trimCell(v)!=="")) rows.push(row);

  return rows;
}

async function fetchCSV(url){
  const res = await fetch(url, { cache:"no-store" });
  if(!res.ok) throw new Error(`æŠ“ä¸åˆ° CSVï¼š${res.status} ${res.statusText}\n${url}`);
  const text = await res.text();
  return parseCSV(text);
}

/** ========= è®€å–å››åŒ–è¡¨ï¼ˆå¤©å¹²â†’å››åŒ–æ˜Ÿåï¼‰ =========
 *  ä½ ç›®å‰çš„æ ¼å¼ï¼šA=å¤©å¹², B=åŒ–ç¥¿, C=åŒ–æ¬Š, D=åŒ–ç§‘, E=åŒ–å¿Œ
 */
function buildTransformMap(rows){
  // rows[0] æ˜¯ headerï¼ˆå¤©å¹² / åŒ–ç¥¿ / åŒ–æ¬Š / åŒ–ç§‘ / åŒ–å¿Œï¼‰
  const map = {};
  for(let i=1;i<rows.length;i++){
    const r = rows[i];
    const stem = trimCell(r[0]);
    if(!stem) continue;
    map[stem] = {
      lu: trimCell(r[1]),
      quan: trimCell(r[2]),
      ke: trimCell(r[3]),
      ji: trimCell(r[4]),
    };
  }
  return map;
}

/** ========= è®€å–æœ¬å‘½ç›¤ï¼ˆä½ å®šç¾©çš„æ¬„ä½ï¼‰ =========
 * A å®®ä½ä»£ç¢¼
 * B å®®ä½ï¼ˆæ ¼å­ä¸­é–“ä¸‹æ–¹ï¼‰
 * C å®®å¹²ï¼ˆå³ä¸‹è§’ï¼‰
 * D èº«å®®ï¼ˆæ˜Ÿè™Ÿï¼‰
 * E~F ä¸»æ˜Ÿï¼ˆé»‘ç²—é«”ï¼‰
 * G~I å‰æ˜Ÿï¼ˆæ·±ç¶ ç²—é«”ï¼‰
 * J~L ç…æ˜Ÿï¼ˆç´…ç²—é«”ï¼‰
 * M~R ä¹™ç´šæ˜Ÿï¼ˆé»‘å­—ï¼‰
 * S~V ç”Ÿå¹´ç¥¿æ¬Šç§‘å¿Œï¼ˆåœ¨å°æ‡‰æ˜Ÿåä¸‹æ–¹ï¼‰
 * W~Z è‡ªåŒ–ç¥¿æ¬Šç§‘å¿Œï¼ˆåœ¨å°æ‡‰æ˜Ÿåä¸Šæ–¹ï¼‰
 */
function buildNatal(rows){
  const header = rows[0] || [];
  const data = [];

  for(let i=1;i<rows.length;i++){
    const r = rows[i];
    const code = trimCell(r[0]); // A
    if(!code) continue;

    const palaceName = trimCell(r[1]); // B
    const stem = trimCell(r[2]);       // C
    const body = trimCell(r[3]);       // Dï¼ˆéç©ºå°±ç•¶èº«å®®ï¼‰

    const main = [trimCell(r[4]), trimCell(r[5])].filter(Boolean);            // E F
    const good = [trimCell(r[6]), trimCell(r[7]), trimCell(r[8])].filter(Boolean); // G H I
    const bad  = [trimCell(r[9]), trimCell(r[10]), trimCell(r[11])].filter(Boolean); // J K L
    const sub  = [trimCell(r[12]),trimCell(r[13]),trimCell(r[14]),trimCell(r[15]),trimCell(r[16]),trimCell(r[17])].filter(Boolean); // M~R

    const born = { // S~V
      lu: trimCell(r[18]),
      quan: trimCell(r[19]),
      ke: trimCell(r[20]),
      ji: trimCell(r[21]),
    };
    const self = { // W~Z
      lu: trimCell(r[22]),
      quan: trimCell(r[23]),
      ke: trimCell(r[24]),
      ji: trimCell(r[25]),
    };

    data.push({
      code, palaceName, stem, isBody: !!body,
      stars: { main, good, bad, sub },
      born, self
    });
  }
  return data;
}

/** ========= SVG ç¹ªè£½ ========= */
const svg = document.getElementById("svg");
let arrowLayer = document.getElementById("arrow-layer");
let boxLayer   = document.getElementById("box-layer");
function clearSVG(){
  // åªæ¸…ç©º layer å…§å®¹ï¼Œä¸ç ´å£ DOM çµæ§‹èˆ‡é †åº
  arrowLayer.innerHTML = "";
  boxLayer.innerHTML = "";
}

function elNS(tag){
  return document.createElementNS("http://www.w3.org/2000/svg", tag);
}

function drawPalaceBox(p){
  const pos = layout[p.code];
  if(!pos) return;

  const g = elNS("g");
  g.setAttribute("data-palace", p.code);

  const rect = elNS("rect");
  rect.setAttribute("class","palace-rect");
  rect.setAttribute("x", pos.x);
  rect.setAttribute("y", pos.y);
  rect.setAttribute("width", layout.w);
  rect.setAttribute("height", layout.h);
  g.appendChild(rect);

  // èº«å®®æ˜Ÿè™Ÿï¼ˆå·¦ä¸Šè§’ï¼‰
  if(p.isBody){
    const star = elNS("text");
    star.setAttribute("class","body-star");
    star.setAttribute("x", pos.x + 10);
    star.setAttribute("y", pos.y + 22);
    star.textContent = "â˜…";
    g.appendChild(star);
  }

  // å®®ä½åç¨±ï¼šä¸­é–“ä¸‹æ–¹
  const name = elNS("text");
  name.setAttribute("class","palace-name");
  name.setAttribute("x", pos.x + layout.w/2);
  name.setAttribute("y", pos.y + layout.h - 18);
  name.textContent = p.palaceName || p.code;
  g.appendChild(name);

  // å®®å¹²ï¼šå³ä¸‹è§’
  const stem = elNS("text");
  stem.setAttribute("class","palace-stem");
  stem.setAttribute("x", pos.x + layout.w - 10);
  stem.setAttribute("y", pos.y + layout.h - 12);
  stem.textContent = p.stem || "";
  g.appendChild(stem);

  // æ˜Ÿæ›œå€åŸŸï¼šä¸ŠåŠéƒ¨
  const area = {
    x: pos.x + 12,
    y: pos.y + 16,
    w: layout.w - 24,
    h: layout.h - 44, // ç•™ä¸‹é¢çµ¦å®®å/å®®å¹²
  };

  // æ”¶é›†æ‰€æœ‰è¦é¡¯ç¤ºçš„æ˜Ÿï¼ˆä¾ä½ çš„åˆ†é¡é †åºï¼‰
const starItems = [];

/* ç¬¬ä¸€æ’ï¼šä¸»æ˜Ÿ + å‰æ˜Ÿ + ç…æ˜Ÿ */
p.stars.main.forEach(s => starItems.push({name:s, cls:"star-main", row:0}));
p.stars.good.forEach(s => starItems.push({name:s, cls:"star-good", row:0}));
p.stars.bad .forEach(s => starItems.push({name:s, cls:"star-bad",  row:0}));

/* ç¬¬äºŒæ’ï¼šä¹™ç´šæ˜Ÿï¼ˆé™æ¬Šï¼‰ */
p.stars.sub.forEach(s => starItems.push({name:s, cls:"star-sub", row:1}));

  // ä½ˆå±€ï¼šæœ€å¤š 3 æ¬„ï¼Œè‡ªå‹•æ›è¡Œ

// ä½ˆå±€ï¼šç¬¬ä¸€æ’(ä¸»æ˜Ÿ/å‰æ˜Ÿ/ç…æ˜Ÿ) + ç¬¬äºŒæ’(ä¹™ç´šæ˜Ÿ)
const cols = 3;
const cellW = area.w / cols;
const rowY = [0, 26]; // ç¬¬ä¸€æ’ / ç¬¬äºŒæ’ çš„ Y åç§»
const visible = starItems;

visible.forEach((it) => {
  const sameRow = visible.filter(x => x.row === it.row);
  const idxInRow = sameRow.indexOf(it);
  const colIndex = idxInRow % cols;

  const cx = area.x + colIndex * cellW + cellW / 2;
  const cy = area.y + rowY[it.row] + 12;

  const t = elNS("text");
  t.setAttribute("class", `star-text ${it.cls}`);
  t.setAttribute("x", cx);
  t.setAttribute("y", cy);
  t.textContent = it.name;
  g.appendChild(t);

  // ç”Ÿå¹´å››åŒ–ï¼šåœ¨ã€Œæ˜Ÿåä¸‹æ–¹ã€
  const bornMark = getMarkForStar(it.name, p.born);
  if (bornMark) {
    const m = elNS("text");
    m.setAttribute("class", `mark ${bornMark.cls}`);
    m.setAttribute("x", cx);
    m.setAttribute("y", cy + 11);
    m.textContent = bornMark.txt;
    g.appendChild(m);
  }

  // è‡ªåŒ–å››åŒ–ï¼šåœ¨ã€Œæ˜Ÿåä¸Šæ–¹ã€
  const selfMark = getMarkForStar(it.name, p.self);
  if (selfMark) {
    const m = elNS("text");
    m.setAttribute("class", `mark ${selfMark.cls}`);
    m.setAttribute("x", cx);
    m.setAttribute("y", cy - 11);
    m.textContent = selfMark.txt;
    g.appendChild(m);
  }

  // è¨˜éŒ„æ˜Ÿåœ¨ SVG çš„ä½ç½®
  it._x = cx;
  it._y = cy;
});

boxLayer.appendChild(g);
  return { g, rectBounds:{x:pos.x,y:pos.y,w:layout.w,h:layout.h} };
}

function getMarkForStar(starName, obj){
  if(!starName) return null;
  if(obj.lu && obj.lu === starName)   return { txt:"ç¥¿", cls:"mark-lu" };
  if(obj.quan && obj.quan === starName) return { txt:"æ¬Š", cls:"mark-quan" };
  if(obj.ke && obj.ke === starName)   return { txt:"ç§‘", cls:"mark-ke" };
  if(obj.ji && obj.ji === starName)   return { txt:"å¿Œ", cls:"mark-ji" };
  return null;
}

/** å»ºç«‹ã€Œæ˜Ÿæ›œâ†’åœ¨å“ªä¸€å®®ã€ç´¢å¼•ï¼ˆç”¨æ–¼é£›åŒ–è½å®®ï¼‰ */
function buildStarIndex(natal){
  const idx = new Map();
  natal.forEach(p => {
    const all = [
      ...p.stars.main, ...p.stars.good, ...p.stars.bad, ...p.stars.sub
    ].filter(Boolean);

    all.forEach(s => {
      // è‹¥åŒåæ˜Ÿå‡ºç¾å¤šæ¬¡ï¼Œå…ˆä¿ç•™ç¬¬ä¸€å€‹ï¼ˆé€šå¸¸ä¸æœƒï¼‰
      if(!idx.has(s)) idx.set(s, p.code);
    });
  });
  return idx;
}

/** ç®—å®®ä¸­å¿ƒé» */
function palaceCenter(code){
  const pos = layout[code];
  return { x: pos.x + layout.w/2, y: pos.y + layout.h/2 };
}

/** ç·šæ®µç«¯é»ç¸®é€²ç›’å­é‚Šç•Œï¼Œé¿å…å£“åˆ°æ–‡å­— */
function clipToRect(fromC, toC, fromCode, toCode, inset=18){
  const a = layout[fromCode], b = layout[toCode];
  const r1 = { x:a.x, y:a.y, w:layout.w, h:layout.h };
  const r2 = { x:b.x, y:b.y, w:layout.w, h:layout.h };

  function intersectRect(center, target, rect){
    // å¾ centerâ†’target çš„æ–¹å‘ï¼Œæ‰¾èˆ‡ rect é‚Šç•Œäº¤é»ï¼ˆå†å¾€å…§ç¸® insetï¼‰
    const dx = target.x - center.x;
    const dy = target.y - center.y;
    if(dx===0 && dy===0) return {x:center.x, y:center.y};

    // ä»¥åƒæ•¸ tï¼Œæ±‚èˆ‡å››é‚Šäº¤é»
    const candidates = [];

    function pushIf(t){
      if(t>0 && isFinite(t)) candidates.push(t);
    }

    // left / right
    pushIf((rect.x - center.x)/dx);
    pushIf((rect.x + rect.w - center.x)/dx);
    // top / bottom
    pushIf((rect.y - center.y)/dy);
    pushIf((rect.y + rect.h - center.y)/dy);

    candidates.sort((m,n)=>m-n);
    // æ‰¾ç¬¬ä¸€å€‹èƒ½è½åœ¨é‚Šç•Œç¯„åœå…§çš„
    for(const t of candidates){
      const x = center.x + dx*t;
      const y = center.y + dy*t;
      const onX = (x >= rect.x-0.5 && x <= rect.x+rect.w+0.5);
      const onY = (y >= rect.y-0.5 && y <= rect.y+rect.h+0.5);
      if(onX && onY){
        // å¾€å…§ç¸® inset
        const len = Math.hypot(dx,dy);
        const ux = dx/len, uy = dy/len;
        return { x: x - ux*inset, y: y - uy*inset };
      }
    }
    return {x:center.x, y:center.y};
  }

  const start = intersectRect(fromC, toC, r1);
  const end   = intersectRect(toC, fromC, r2); // å¾ toC å¾€å›ç®—
  return { start, end };
}

/** è¼•å¾®å½æ›² + å¾®åç§»ï¼šè®“åŒèµ·é»ç·šæ¢ä¸å®Œå…¨é‡ç–Š */
function curvedPath(start, end, bend){
  const mx = (start.x + end.x)/2;
  const my = (start.y + end.y)/2;

  // å‚ç›´å‘é‡åšæ§åˆ¶é»åç§»
  const dx = end.x - start.x;
  const dy = end.y - start.y;
  const len = Math.hypot(dx,dy) || 1;
  const nx = -dy/len;
  const ny = dx/len;

  const cx = mx + nx*bend;
  const cy = my + ny*bend;

  return `M ${start.x} ${start.y} Q ${cx} ${cy} ${end.x} ${end.y}`;
}

/** ç•«ä¸€æ¢ç®­é ­ */
function drawArrow(fromCode, toCode, type, orderInFrom = 0) {
  if (fromCode === toCode) return;

  const fromC = palaceCenter(fromCode);
  const toC = palaceCenter(toCode);

  const { start, end } = clipToRect(fromC, toC, fromCode, toCode, 22);

  const dx = end.x - start.x;
  const dy = end.y - start.y;
  const dist = Math.hypot(dx, dy) || 1;

  // è·é›¢è¶ŠçŸ­ï¼Œå½æ›²è¶Šå¤§ï¼ˆé¿å…çŸ­ç·šæ“ åœ¨ä¸€èµ·ï¼‰
  const distanceFactor = Math.max(0.6, 220 / dist);
  const bend = (orderInFrom - 1.5) * 40 * distanceFactor;

  const d = curvedPath(start, end, bend);

  const path = elNS("path");
  const cls =
    (type === "ç¥¿") ? "arrow arrow-lu" :
    (type === "æ¬Š") ? "arrow arrow-quan" :
    (type === "ç§‘") ? "arrow arrow-ke" :
    "arrow arrow-ji";

  path.setAttribute("class", cls);
  path.setAttribute("d", d);

  const marker =
    (type === "ç¥¿") ? "url(#m-lu)" :
    (type === "æ¬Š") ? "url(#m-quan)" :
    (type === "ç§‘") ? "url(#m-ke)" :
    "url(#m-ji)";

  path.setAttribute("marker-end", marker);

  // æ”¾åˆ°æœ€ä¸Šå±¤ï¼ˆé¿å…è¢«æ ¼å­è“‹ä½ï¼‰
arrowLayer.appendChild(path);
}

/** ========= ä¸»æµç¨‹ ========= */
async function main(){
  try{
    clearSVG();

    const [natalRows, transRows] = await Promise.all([
      fetchCSV(NATAL_CSV_URL),
      fetchCSV(TRANSFORM_CSV_URL),
    ]);

const natal = buildNatal(natalRows);
const transformMap = buildTransformMap(transRows);
const starIndex = buildStarIndex(natal);

// ===== Step 1ï¼šå…ˆç•«æ‰€æœ‰ç®­é ­ =====
const fromCount = new Map();

natal.forEach(p => {
  const t = transformMap[p.stem];
  if (!t) return;

  const pairs = [
    { type: "ç¥¿", star: t.lu },
    { type: "æ¬Š", star: t.quan },
    { type: "ç§‘", star: t.ke },
    { type: "å¿Œ", star: t.ji },
  ].filter(x => x.star);

  pairs.forEach(pair => {
    const toCode = starIndex.get(pair.star);
    if (!toCode) return;

    const k = p.code;
    const cnt = (fromCount.get(k) ?? 0);
    fromCount.set(k, cnt + 1);

    drawArrow(p.code, toCode, pair.type, cnt);
  });
});

// ===== Step 2ï¼šå†ç•« 12 å®®èˆ‡æ˜Ÿæ›œï¼ˆä¸Šå±¤ï¼‰=====
natal.forEach(p => drawPalaceBox(p));

  }catch(e){
    showError(String(e && e.message ? e.message : e));
  }
}

main();
</script>
</body>
</html>
